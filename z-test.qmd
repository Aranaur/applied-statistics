# $Z$-критерій Фішера {#sec-z-test}

```{python}
#| include: false

with open("_common.py") as f:
    exec(f.read())
```

У цьому розділі ми розглянемо $Z$-критерій Фішера, який використовується для перевірки гіпотез про середнє значення генеральної сукупності з відомою дисперсією.

Далі, для виведення критеріїв нам потрібен нормальний розподіл. *Потому що саме цьому розподілу підпорядковується середнє вибірок*. Тож давайте подивимося, що це взагалі таке, як з ним працювати в Python й які в нього є властивості.

## Нормальний розподіл {#sec-normal-distribution}

Нормальний розподіл $\mathcal{N}(\mu, \sigma^2)$ --- неперервний розподіл, у якому щільність спадає зі збільшенням відстані від математичного сподівання $\mu$ за швидкістю, пропорційною квадрату відстані (див. [формулу -@eq-normal-density]).

$$
f(x) = \frac{1}{\sigma\sqrt{2\pi}}e^{-\frac{1}{2}\left(\frac{x-\mu}{\sigma}\right)^2},
$$ {#eq-normal-density}
де $x$ --- випадкова величина, $\mu$ --- математичне сподівання, $\sigma^2$ --- дисперсія.

На графіку нижче показано, як виглядає нормальний розподіл з різними параметрами $\mu$ та $\sigma^2$.

::: {#lst-normal-distribution}

```{python}
#| eval: false

x = np.linspace(-5, 5, 1000)
params = [(0, 1), (0, 2), (1, 1), (1, 2), (2, 1), (2, 2)]

for mu, sigma in params:
    plt.plot(x, norm.pdf(x, mu, sigma), label=f'μ={mu}, σ={sigma}')

plt.xlabel('x')
plt.ylabel('f(x)')
plt.legend()
plt.show()
```

Візуалізація нормального розподілу з різними параметрами $\mu$ та $\sigma^2$.
:::

```{python}
#| label: fig-normal-distribution
#| fig-cap: Нормальний розподіл з різними параметрами
#| echo: false

x = np.linspace(-5, 5, 1000)
params = [(0, 1), (0, 2), (1, 1), (1, 2), (2, 1), (2, 2)]

for mu, sigma in params:
    plt.plot(x, norm.pdf(x, mu, sigma), label=f'μ={mu}, σ={sigma}')

plt.xlabel('x')
plt.ylabel('f(x)')
plt.legend()
plt.show()
```

## Нормальний розподіл у Python {#sec-normal-distribution-python}

Нехай ми хочемо задати розподіл $\mathcal{N}(\mu, \sigma^2)$. Для цього є клас `norm`[^py-norm].

[^py-norm]: Документація доступна за посиланням <https://docs.scipy.org/doc/scipy/reference/generated/scipy.stats.norm.html>.

Параметри класу:

- `loc` --- це $\mu$
- `scale` --- це $\sigma$, або **стандартне відхилення**. Не дисперсія!

Методи класу:

- `rvs()` --- згенерувати випадкові числа з розподілу $\mathcal{N}(\mu, \sigma^2)$
- `cdf(x)` --- кумулятивна функція розподілу (cumulative distribution function, CDF) в точці $x$, ймовірність того, що випадкова величина $X$ менша або дорівнює $x$.
- `ppf(q)` --- квантиль функції розподілу (percent-point function, PPF) для ймовірності $q$, ймовірність того, що випадкова величина $X$ менша або дорівнює $q$.
- `pdf(x)` --- щільність ймовірності (probability density function, PDF) в точці $x$, ймовірність того, що випадкова величина $X$ дорівнює $x$.

CDF та PPF --- це функції, які пов'язані між собою. CDF визначає ймовірність того, що випадкова величина $X$ менша або дорівнює $x$, а PPF визначає значення $x$, для якого ймовірність $X$ менша або дорівнює $q$.

Ініціалізуємо клас `norm` з параметрами $\mu = 0$ та $\sigma = 1$ (стандартний нормальний розподіл). Далі, згенеруємо випадкову вибірку з 50 спостережень, а також обчислимо PDF, CDF та PPF для $x = 1.5$.

::: {#lst-normal-distribution-2}

```{python}
std_norm = norm(loc=0, scale=1) # <1>

rnorm = std_norm.rvs(size=50, random_state=42) # <2>

dnrom = std_norm.pdf(1.5) # <3>
pnorm = std_norm.cdf(1.5) # <4>
qnorm = std_norm.ppf(0.933) # <5>
```
1. Ініціалізація класу `norm` з параметрами $\mu = 0$ та $\sigma = 1$.
2. Генерація випадкової вибірки з 50 спостережень.
3. Обчислення PDF для $x = 1.5$.
4. Обчислення CDF для $x = 1.5$.
5. Обчислення PPF для $q = 0.933$.

Нормальний розподіл у Python.
:::

Візуалізація методів класу `norm` показана на [рисунку -@fig-normal-distribution-2].

```{python}
#| label: fig-normal-distribution-2
#| fig-cap: Демонстрація методів класу `norm`
#| echo: false

mu, sigma = 0, 1
q = 1.5


# Генерація випадкової вибірки
rnorm = norm.rvs(loc=mu, scale=sigma, size=50, random_state=42)

# Щільність розподілу (PDF)
x = np.linspace(-4, 4, 1000)
dnrom = norm.pdf(q, loc=mu, scale=sigma)
pnorm = norm.cdf(q, loc=mu, scale=sigma)
qnorm = norm.ppf(0.933, loc=mu, scale=sigma)

# PDF for x
plt.plot(x, norm.pdf(x, loc=mu, scale=sigma), label='PDF', color = turquoise)

# Random sample
plt.scatter(rnorm, np.random.normal(0, 0.005, size=rnorm.shape), color=red_pink, alpha=0.5, s=10)
plt.annotate('norm.rvs(50)', xy=(-1, 0), xytext=(-3, 0.2), color=red_pink, ha = 'center',
             arrowprops=dict(facecolor=red_pink, shrink=0.05))

# CDF for 2
plt.fill_between(x, norm.pdf(x, loc=mu, scale=sigma), where=(x <= q), color=turquoise, alpha=0.2)
plt.annotate('norm.cdf(1.5) = 0.933', xy=(1, 0.15), xytext=(1.5, 0.3), color=turquoise,
             arrowprops=dict(facecolor=turquoise, shrink=0.05))

# PDF for 2
plt.scatter(q, norm.pdf(q, loc=mu, scale=sigma), color=orange, s=15, zorder=5)
plt.plot([q, q], [0, dnrom], color=orange, linewidth=1, linestyle='--')
plt.annotate('norm.pdf(1.5) = 0.129', xy=(q, dnrom), xytext=(2, 0.2), color=orange, ha = 'left',
             arrowprops=dict(facecolor=orange, shrink=0.05))

# PPF for 0.977
plt.scatter(q, 0, color=purple, label='qnorm(0.977)', s=15, zorder=5)
plt.annotate('norm.ppf(0.933) = 1.5', xy=(q, 0), xytext=(2, 0.1), color=purple, ha = 'left',
             arrowprops=dict(facecolor=purple, shrink=0.05))


plt.xlabel('x')
plt.ylabel('Щільність')
plt.show()
```